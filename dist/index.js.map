{"version":3,"file":"index.js","sources":["../src/useBalances.js","../src/useBlockHeight.js","../src/useDataDump.js","../src/useDeletedWalletIds.js","../src/useEnabledTokens.js","../src/useFiatCurrencyCode.js","../src/useLocalStorage.js","../src/useLocalUsers.js","../src/useName.js","../src/useOtpResetDate.js","../src/useSyncedStorage.js"],"sourcesContent":["// @flow\n\nimport { type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useState } from 'react'\n\ntype State = $PropertyType<EdgeCurrencyWallet, 'balances'> | null\n\nexport const useBalances = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [balances, setBalances] = useState<State>(wallet ? wallet.balances : null)\n\n  const effect = () => {\n    if (!wallet) return // mount with null\n    setBalances(wallet.balances)\n    const unsubscribe = wallet.watch('balances', setBalances) // mount with wallet / null -> wallet / walletA -> walletB (2)\n    return unsubscribe // unmount with wallet / walletA -> walletB (1) / wallet -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [wallet]) // onUpdate\n\n  return balances\n}\n","// @flow\n\nimport { type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useState } from 'react'\n\ntype State = $PropertyType<EdgeCurrencyWallet, 'blockHeight'> | null\n\nexport const useBlockHeight = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [blockHeight, setBlockHeight] = useState<State>(wallet ? wallet.blockHeight : null)\n\n  const effect = () => {\n    if (!wallet) return // mount with null\n    setBlockHeight(wallet.blockHeight)\n    const unsubscribe = wallet.watch('blockHeight', setBlockHeight) // mount with wallet / null -> wallet / walletA -> walletB (2)\n    return unsubscribe // unmount with wallet / walletA -> walletB (1) / wallet -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [wallet]) // onUpdate\n\n  return blockHeight\n}\n","// @flow\n\nimport { type EdgeCurrencyWallet, type EdgeDataDump } from 'edge-core-js'\nimport { useReducer } from 'react'\n\ntype READ_DATA_DUMP_START = {| type: 'READ_DATA_DUMP_START' |}\ntype READ_DATA_DUMP_SUCCESS = {| dataDump: EdgeDataDump, type: 'READ_DATA_DUMP_SUCCESS' |}\ntype READ_DATA_DUMP_ERROR = {| error: Error, type: 'READ_DATA_DUMP_ERROR' |}\ntype Action = READ_DATA_DUMP_START | READ_DATA_DUMP_SUCCESS | READ_DATA_DUMP_ERROR\n\ntype State = {\n  dataDump: EdgeDataDump | null,\n  error: Error | null,\n  pending: boolean\n}\n\nconst initialState: State = {\n  dataDump: null,\n  error: null,\n  pending: false\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'READ_DATA_DUMP_START': {\n      return { ...state, pending: true, error: null }\n    }\n\n    case 'READ_DATA_DUMP_SUCCESS': {\n      return { ...state, pending: false, dataDump: action.dataDump }\n    }\n\n    case 'READ_DATA_DUMP_ERROR': {\n      return { ...state, pending: false, error: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useDataDump = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const getDataDump = () => {\n    if (!wallet) return\n    dispatch({ type: 'READ_DATA_DUMP_START' })\n    wallet\n      .dumpData()\n      .then((dataDump: EdgeDataDump) => dispatch({ type: 'READ_DATA_DUMP_SUCCESS', dataDump }))\n      .catch((error: Error) => dispatch({ type: 'READ_DATA_DUMP_ERROR', error }))\n  }\n\n  return { ...state, getDataDump }\n}\n","// @flow\n\nimport { type EdgeAccount, type EdgeWalletInfoFull } from 'edge-core-js'\nimport { useEffect, useState } from 'react'\n\ntype State = Array<string> | null\n\nexport const useDeletedWalletIds = (account: EdgeAccount | null | void) => {\n  const [deletedWalletIds, setDeletedWalletIds] = useState<State>(account ? getDeletedWalletIds(account.allKeys) : null)\n\n  const effect = () => {\n    if (!account) return // mount with null\n    setDeletedWalletIds(getDeletedWalletIds(account.allKeys)) // mount with account / null -> account / accountA -> accountB (2)\n    const unsubscribe = account.watch('allKeys', allKeys => setDeletedWalletIds(getDeletedWalletIds(allKeys))) // mount with account / null -> account / accountA -> accountB (2)\n    return unsubscribe // unmount with account / accountA -> accountB (1) / account -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [account]) // onUpdate\n\n  return deletedWalletIds\n}\n\nconst getDeletedWalletIds = (walletInfos: Array<EdgeWalletInfoFull>) => {\n  const deletedWalletInfos: Array<EdgeWalletInfoFull> = walletInfos.filter(key => key.deleted)\n  const deletedWalletIds: Array<string> = deletedWalletInfos.map((key: EdgeWalletInfoFull) => key.id)\n\n  return deletedWalletIds\n}\n","// @flow\n\nimport { type EdgeCurrencyWallet, type EdgeTokenInfo } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\ntype READ_ENABLED_TOKENS_START = {| type: 'READ_ENABLED_TOKENS_START' |}\ntype READ_ENABLED_TOKENS_SUCCESS = {| enabledTokens: Array<string>, type: 'READ_ENABLED_TOKENS_SUCCESS' |}\ntype READ_ENABLED_TOKENS_ERROR = {| error: Error, type: 'READ_ENABLED_TOKENS_ERROR' |}\n\ntype ENABLE_TOKENS_START = {| type: 'ENABLE_TOKENS_START' |}\ntype ENABLE_TOKENS_SUCCESS = {| type: 'ENABLE_TOKENS_SUCCESS' |}\ntype ENABLE_TOKENS_ERROR = {| error: Error, type: 'ENABLE_TOKENS_ERROR' |}\n\ntype DISABLE_TOKENS_START = {| type: 'DISABLE_TOKENS_START' |}\ntype DISABLE_TOKENS_SUCCESS = {| type: 'DISABLE_TOKENS_SUCCESS' |}\ntype DISABLE_TOKENS_ERROR = {| error: Error, type: 'DISABLE_TOKENS_ERROR' |}\n\ntype ADD_CUSTOM_TOKEN_START = {| type: 'ADD_CUSTOM_TOKEN_START' |}\ntype ADD_CUSTOM_TOKEN_SUCCESS = {| type: 'ADD_CUSTOM_TOKEN_SUCCESS' |}\ntype ADD_CUSTOM_TOKEN_ERROR = {| error: Error, type: 'ADD_CUSTOM_TOKEN_ERROR' |}\n\ntype Action =\n  | READ_ENABLED_TOKENS_START\n  | READ_ENABLED_TOKENS_SUCCESS\n  | READ_ENABLED_TOKENS_ERROR\n  | DISABLE_TOKENS_START\n  | ENABLE_TOKENS_START\n  | ENABLE_TOKENS_SUCCESS\n  | ENABLE_TOKENS_ERROR\n  | DISABLE_TOKENS_START\n  | DISABLE_TOKENS_SUCCESS\n  | DISABLE_TOKENS_ERROR\n  | ADD_CUSTOM_TOKEN_START\n  | ADD_CUSTOM_TOKEN_SUCCESS\n  | ADD_CUSTOM_TOKEN_ERROR\n\ntype State = {\n  addCustomTokenError: Error | null,\n  addCustomTokenPending: boolean,\n\n  disableTokensError: Error | null,\n  disableTokensPending: boolean,\n\n  enableTokensError: Error | null,\n  enableTokensPending: boolean,\n\n  enabledTokens: Array<string> | null,\n\n  readEnabledTokensError: Error | null,\n  readEnabledTokensPending: boolean\n}\n\nconst initialState: State = {\n  addCustomTokenError: null,\n  addCustomTokenPending: false,\n\n  disableTokensError: null,\n  disableTokensPending: false,\n\n  enableTokensError: null,\n  enableTokensPending: false,\n\n  enabledTokens: null,\n\n  readEnabledTokensError: null,\n  readEnabledTokensPending: false\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'READ_ENABLED_TOKENS_START': {\n      return { ...state, readEnabledTokensPending: true, readEnabledTokensError: null }\n    }\n    case 'ENABLE_TOKENS_START': {\n      return { ...state, enableTokensPending: true, enableTokensError: null }\n    }\n    case 'DISABLE_TOKENS_START': {\n      return { ...state, disableTokensPending: true, disableTokensError: null }\n    }\n    case 'ADD_CUSTOM_TOKEN_START': {\n      return { ...state, addCustomTokenPending: true, addCustomTokenError: null }\n    }\n\n    case 'READ_ENABLED_TOKENS_SUCCESS': {\n      return { ...state, readEnabledTokensPending: false, enabledTokens: action.enabledTokens }\n    }\n    case 'ENABLE_TOKENS_SUCCESS': {\n      return { ...state, enableTokensPending: false }\n    }\n    case 'DISABLE_TOKENS_SUCCESS': {\n      return { ...state, disableTokensPending: false }\n    }\n    case 'ADD_CUSTOM_TOKEN_SUCCESS': {\n      return { ...state, addCustomTokenPending: false }\n    }\n\n    case 'READ_ENABLED_TOKENS_ERROR': {\n      return { ...state, readEnabledTokensPending: false, readEnabledtokensError: action.error }\n    }\n    case 'ENABLE_TOKENS_ERROR': {\n      return { ...state, enableTokensPending: false, enableTokenError: action.error }\n    }\n    case 'DISABLE_TOKENS_ERROR': {\n      return { ...state, disableTokensPending: false, disableTokenError: action.error }\n    }\n    case 'ADD_CUSTOM_TOKEN_ERROR': {\n      return { ...state, addCustomTokenPending: false, addCustomTokenError: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useEnabledTokens = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const enableTokens = (tokens: Array<string>) => {\n    if (!wallet) return\n    dispatch({ type: 'ENABLE_TOKENS_START' })\n    wallet\n      .enableTokens(tokens)\n      .then(() => dispatch({ type: 'ENABLE_TOKENS_SUCCESS' }))\n      .catch((error: Error) => dispatch({ type: 'ENABLE_TOKENS_ERROR', error }))\n  }\n\n  const disableTokens = (tokens: Array<string>) => {\n    if (!wallet) return\n    dispatch({ type: 'DISABLE_TOKENS_START' })\n    wallet\n      .disableTokens(tokens)\n      .then(() => dispatch({ type: 'DISABLE_TOKENS_SUCCESS' }))\n      .catch((error: Error) => dispatch({ type: 'DISABLE_TOKENS_ERROR', error }))\n  }\n\n  const addCustomToken = (tokenInfo: EdgeTokenInfo) => {\n    if (!wallet) return\n    dispatch({ type: 'ADD_CUSTOM_TOKEN_START' })\n    wallet\n      .addCustomToken(tokenInfo)\n      .then(() => dispatch({ type: 'ADD_CUSTOM_TOKEN_SUCCESS' }))\n      .catch((error: Error) => dispatch({ type: 'ADD_CUSTOM_TOKEN_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!wallet) return // mount with null\n    dispatch({ type: 'READ_ENABLED_TOKENS_START' })\n    wallet\n      .getEnabledTokens()\n      .then((enabledTokens: Array<string>) => dispatch({ type: 'READ_ENABLED_TOKENS_SUCCESS', enabledTokens }))\n      .catch((error: Error) => dispatch({ type: 'READ_ENABLED_TOKENS_ERROR', error }))\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [wallet]) // onUpdate\n\n  return { ...state, enableTokens, disableTokens, addCustomToken }\n}\n","// @flow\n\nimport { type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\ntype WRITE_FIAT_CURRENCY_CODE_START = {| type: 'WRITE_FIAT_CURRENCY_CODE_START' |}\ntype WRITE_FIAT_CURRENCY_CODE_SUCCESS = {| fiatCurrencyCode: string, type: 'WRITE_FIAT_CURRENCY_CODE_SUCCESS' |}\ntype WRITE_FIAT_CURRENCY_CODE_ERROR = {| error: Error, type: 'WRITE_FIAT_CURRENCY_CODE_ERROR' |}\ntype READ_FIAT_CURRENCY_CODE_SUCCESS = {| fiatCurrencyCode: string, type: 'READ_FIAT_CURRENCY_CODE_SUCCESS' |}\ntype Action =\n  | WRITE_FIAT_CURRENCY_CODE_START\n  | WRITE_FIAT_CURRENCY_CODE_SUCCESS\n  | WRITE_FIAT_CURRENCY_CODE_ERROR\n  | READ_FIAT_CURRENCY_CODE_SUCCESS\n\ntype State = {\n  error: Error | null,\n  fiatCurrencyCode: string | null,\n  pending: boolean\n}\n\nconst initialState: State = {\n  fiatCurrencyCode: null,\n  pending: false,\n  error: null\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'WRITE_FIAT_CURRENCY_CODE_START': {\n      return { ...state, pending: true, error: null }\n    }\n\n    case 'READ_FIAT_CURRENCY_CODE_SUCCESS':\n    case 'WRITE_FIAT_CURRENCY_CODE_SUCCESS': {\n      return { ...state, pending: false, fiatCurrencyCode: action.fiatCurrencyCode }\n    }\n\n    case 'WRITE_FIAT_CURRENCY_CODE_ERROR': {\n      return { ...state, pending: false, error: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useFiatCurrencyCode = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const setFiatCurrencyCode = (fiatCurrencyCode: string) => {\n    if (!wallet) return\n    dispatch({ type: 'WRITE_FIAT_CURRENCY_CODE_START' })\n    wallet\n      .setFiatCurrencyCode(fiatCurrencyCode)\n      .then(() => dispatch({ type: 'WRITE_FIAT_CURRENCY_CODE_SUCCESS', fiatCurrencyCode }))\n      .catch((error: Error) => dispatch({ type: 'WRITE_FIAT_CURRENCY_CODE_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!wallet) return // mount with null\n    dispatch({ type: 'READ_FIAT_CURRENCY_CODE_SUCCESS', fiatCurrencyCode: wallet.fiatCurrencyCode })\n    const unsubscribe = wallet.watch(\n      'fiatCurrencyCode',\n      (fiatCurrencyCode: $PropertyType<EdgeCurrencyWallet, 'fiatCurrencyCode'>) =>\n        dispatch({ type: 'WRITE_FIAT_CURRENCY_CODE_SUCCESS', fiatCurrencyCode })\n    ) // mount with wallet / null -> wallet / walletA -> walletB (2)\n    return unsubscribe // unmount with wallet / walletA -> walletB (1) / wallet -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [wallet]) // onUpdate\n\n  return { ...state, setFiatCurrencyCode }\n}\n","// @flow\n\nimport { type EdgeAccount, type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\nexport type Stringifyable = string | number | { [string]: Stringifyable } | Array<Stringifyable>\n\ntype WRITE_START = {| type: 'WRITE_START' |}\ntype WRITE_SUCCESS = {| data: Stringifyable, type: 'WRITE_SUCCESS' |}\ntype WRITE_ERROR = {| error: Error, type: 'WRITE_ERROR' |}\ntype READ_START = {| type: 'READ_START' |}\ntype READ_SUCCESS = {| data: Stringifyable, type: 'READ_SUCCESS' |}\ntype READ_ERROR = {| error: Error, type: 'READ_ERROR' |}\ntype Action = WRITE_START | WRITE_SUCCESS | WRITE_ERROR | READ_START | READ_SUCCESS | READ_ERROR\n\ntype State = {\n  data: Stringifyable | null,\n  readError: Error | null,\n  readPending: boolean,\n  writeError: Error | null,\n  writePending: boolean\n}\n\nconst initialState: State = {\n  data: null,\n  writePending: false,\n  writeError: null,\n  readPending: false,\n  readError: null\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'READ_START': {\n      return { ...state, readPending: true, readError: null }\n    }\n    case 'WRITE_START': {\n      return { ...state, writePending: true, writeError: null }\n    }\n\n    case 'READ_SUCCESS': {\n      return { ...state, readPending: false, data: action.data }\n    }\n    case 'WRITE_SUCCESS': {\n      return { ...state, writePending: false, data: action.data }\n    }\n\n    case 'WRITE_ERROR': {\n      return { ...state, writePending: false, writeError: action.error }\n    }\n    case 'READ_ERROR': {\n      return { ...state, readPending: false, readError: action.error }\n    }\n    default:\n      return state\n  }\n}\n\nexport const useLocalStorage = (\n  storageContext: EdgeAccount | EdgeCurrencyWallet | null | void,\n  path: string | null | void\n) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const setData = (data: Stringifyable) => {\n    if (!storageContext || !path) return\n    dispatch({ type: 'WRITE_START' })\n    storageContext.localDisklet\n      .setText(path, JSON.stringify(data))\n      .then(() => dispatch({ type: 'WRITE_SUCCESS', data }))\n      .catch((error: Error) => dispatch({ type: 'WRITE_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!storageContext || !path) return // mount with null\n    dispatch({ type: 'READ_START' })\n    storageContext.localDisklet\n      .getText(path)\n      .then((data: string) => dispatch({ type: 'READ_SUCCESS', data: JSON.parse(data) }))\n      .catch((error: Error) => dispatch({ type: 'READ_ERROR', error })) // mount with storageContext / null -> storageContext / storageContextA -> storageContextB\n\n    const unsubscribe = storageContext.watch(\n      'localDisklet',\n      (localDisklet: $PropertyType<EdgeAccount | EdgeCurrencyWallet, 'localDisklet'>) => {\n        if (!storageContext || !path) return\n        localDisklet\n          .getText(path)\n          .then((data: string) => dispatch({ type: 'READ_SUCCESS', data: JSON.parse(data) }))\n          .catch((error: Error) => dispatch({ type: 'READ_ERROR', error }))\n      }\n    )\n    return unsubscribe // unmount with storageContext / storageContextA -> storageContextB (1) / storageContext -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [storageContext]) // onUpdate\n\n  return { ...state, setData }\n}\n","// @flow\n\nimport { type EdgeContext, type EdgeUserInfo } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\ntype READ_LOCAL_USERS_SUCCESS = { localUsers: Array<EdgeUserInfo>, type: 'READ_LOCAL_USERS_SUCCESS' }\ntype DELETE_LOCAL_USER_START = { type: 'DELETE_LOCAL_USER_START' }\ntype DELETE_LOCAL_USER_SUCCESS = { type: 'DELETE_LOCAL_USER_SUCCESS' }\ntype DELETE_LOCAL_USER_ERROR = { error: Error, type: 'DELETE_LOCAL_USER_ERROR' }\n\ntype Action = READ_LOCAL_USERS_SUCCESS | DELETE_LOCAL_USER_START | DELETE_LOCAL_USER_SUCCESS | DELETE_LOCAL_USER_ERROR\n\ntype State = { deletePending: boolean, localUsers: Array<EdgeUserInfo> | null }\n\nconst initialState = { deletePending: false, localUsers: null }\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'READ_LOCAL_USERS_SUCCESS': {\n      return { ...state, localUsers: action.localUsers }\n    }\n\n    case 'DELETE_LOCAL_USER_START': {\n      return { ...state, deletePending: true, error: null }\n    }\n\n    case 'DELETE_LOCAL_USER_SUCCESS': {\n      return { ...state, deletePending: false }\n    }\n\n    case 'DELETE_LOCAL_USER_ERROR': {\n      return { ...state, deletePending: false, error: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useLocalUsers = (context: EdgeContext | null | void) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const deleteLocalUser = (username: string) => {\n    if (!context) return\n    dispatch({ type: 'DELETE_LOCAL_USER_START' })\n    context\n      .deleteLocalAccount(username)\n      .then(() => dispatch({ type: 'DELETE_LOCAL_USER_SUCCESS' }))\n      .catch((error: Error) => dispatch({ type: 'DELETE_LOCAL_USER_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!context) return // mount with null\n    dispatch({ type: 'READ_LOCAL_USERS_SUCCESS', localUsers: context.localUsers })\n    const unsubscribe = context.watch('localUsers', (localUsers: Array<EdgeUserInfo>) =>\n      dispatch({ type: 'READ_LOCAL_USERS_SUCCESS', localUsers })\n    ) // mount with context / null -> context / contextA -> contextB (2)\n    return unsubscribe // unmount with context / contextA -> contextB (1) / context -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [context]) // onUpdate\n\n  return { ...state, deleteLocalUser }\n}\n","// @flow\n\nimport { type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\ntype WRITE_NAME_START = {| type: 'WRITE_NAME_START' |}\ntype WRITE_NAME_SUCCESS = {| name: string | null, type: 'WRITE_NAME_SUCCESS' |}\ntype WRITE_NAME_ERROR = {| error: Error, type: 'WRITE_NAME_ERROR' |}\ntype READ_NAME_SUCCESS = {| name: string | null, type: 'READ_NAME_SUCCESS' |}\ntype Action = WRITE_NAME_START | WRITE_NAME_SUCCESS | WRITE_NAME_ERROR | READ_NAME_SUCCESS\n\ntype State = {\n  error: Error | null,\n  name: string | null,\n  pending: boolean\n}\n\nconst initialState: State = {\n  name: null,\n  pending: false,\n  error: null\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'WRITE_NAME_START': {\n      return { ...state, pending: true, error: null }\n    }\n\n    case 'READ_NAME_SUCCESS':\n    case 'WRITE_NAME_SUCCESS': {\n      return { ...state, pending: false, name: action.name }\n    }\n\n    case 'WRITE_NAME_ERROR': {\n      return { ...state, pending: false, error: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useName = (wallet: EdgeCurrencyWallet | null | void) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const setName = (name: string) => {\n    if (!wallet) return\n    dispatch({ type: 'WRITE_NAME_START' })\n    wallet\n      .renameWallet(name)\n      .then(() => dispatch({ type: 'WRITE_NAME_SUCCESS', name }))\n      .catch((error: Error) => dispatch({ type: 'WRITE_NAME_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!wallet) return // mount with null\n    dispatch({ type: 'READ_NAME_SUCCESS', name: wallet.name })\n    const unsubscribe = wallet.watch('name', (name: $PropertyType<EdgeCurrencyWallet, 'name'>) =>\n      dispatch({ type: 'WRITE_NAME_SUCCESS', name })\n    ) // mount with wallet / null -> wallet / walletA -> walletB (2)\n    return unsubscribe // unmount with wallet / walletA -> walletB (1) / wallet -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [wallet]) // onUpdate\n\n  return { ...state, setName }\n}\n","// @flow\n\nimport { type EdgeAccount } from 'edge-core-js'\nimport { useEffect, useState } from 'react'\n\ntype State = $PropertyType<EdgeAccount, 'otpResetDate'> | null\n\nexport const useOtpResetDate = (account: EdgeAccount | null | void) => {\n  const [otpResetDate, setOtpResetDate] = useState<State>(account ? account.otpResetDate : null)\n\n  const effect = () => {\n    if (!account) return // mount with null\n    setOtpResetDate(account.otpResetDate) // mount with account / null -> account / accountA -> accountB (2)\n    const unsubscribe = account.watch('otpResetDate', setOtpResetDate) // mount with account / null -> account / accountA -> accountB (2)\n    return unsubscribe // unmount with account / accountA -> accountB (1) / account -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [account]) // onUpdate\n\n  return otpResetDate\n}\n","// @flow\n\nimport { type EdgeAccount, type EdgeCurrencyWallet } from 'edge-core-js'\nimport { useEffect, useReducer } from 'react'\n\nexport type Stringifyable = string | number | { [string]: Stringifyable } | Array<Stringifyable>\n\ntype WRITE_START = {| type: 'WRITE_START' |}\ntype WRITE_SUCCESS = {| data: Stringifyable, type: 'WRITE_SUCCESS' |}\ntype WRITE_ERROR = {| error: Error, type: 'WRITE_ERROR' |}\ntype READ_START = {| type: 'READ_START' |}\ntype READ_SUCCESS = {| data: Stringifyable, type: 'READ_SUCCESS' |}\ntype READ_ERROR = {| error: Error, type: 'READ_ERROR' |}\ntype Action = WRITE_START | WRITE_SUCCESS | WRITE_ERROR | READ_START | READ_SUCCESS | READ_ERROR\n\ntype State = {\n  data: Stringifyable | null,\n  readError: Error | null,\n  readPending: boolean,\n  writeError: Error | null,\n  writePending: boolean\n}\n\nconst initialState: State = {\n  data: null,\n  writePending: false,\n  writeError: null,\n  readPending: false,\n  readError: null\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'READ_START': {\n      return { ...state, readPending: true, readError: null }\n    }\n    case 'WRITE_START': {\n      return { ...state, writePending: true, writeError: null }\n    }\n\n    case 'READ_SUCCESS': {\n      return { ...state, readPending: false, data: action.data }\n    }\n    case 'WRITE_SUCCESS': {\n      return { ...state, writePending: false, data: action.data }\n    }\n\n    case 'READ_ERROR': {\n      return { ...state, readPending: false, readError: action.error }\n    }\n    case 'WRITE_ERROR': {\n      return { ...state, writePending: false, writeError: action.error }\n    }\n\n    default:\n      return state\n  }\n}\n\nexport const useSyncedStorage = (\n  storageContext: EdgeAccount | EdgeCurrencyWallet | null | void,\n  path: string | null | void\n) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  const setData = (data: Stringifyable) => {\n    if (!storageContext || !path) return\n    dispatch({ type: 'WRITE_START' })\n    storageContext.disklet\n      .setText(path, JSON.stringify(data))\n      .then(() => dispatch({ type: 'WRITE_SUCCESS', data }))\n      .catch((error: Error) => dispatch({ type: 'WRITE_ERROR', error }))\n  }\n\n  const effect = () => {\n    if (!storageContext || !path) return // mount with null\n    dispatch({ type: 'READ_START' })\n    storageContext.disklet\n      .getText(path)\n      .then((data: string) => dispatch({ type: 'READ_SUCCESS', data: JSON.parse(data) }))\n      .catch((error: Error) => dispatch({ type: 'READ_ERROR', error })) // mount with storageContext / null -> storageContext / storageContextA -> storageContextB\n\n    const unsubscribe = storageContext.watch(\n      'disklet',\n      (disklet: $PropertyType<EdgeAccount | EdgeCurrencyWallet, 'disklet'>) => {\n        if (!storageContext || !path) return\n        disklet\n          .getText(path)\n          .then((data: string) => dispatch({ type: 'READ_SUCCESS', data: JSON.parse(data) }))\n          .catch((error: Error) => dispatch({ type: 'READ_ERROR', error }))\n      }\n    )\n    return unsubscribe // unmount with storageContext / storageContextA -> storageContextB (1) / storageContext -> null\n  }\n\n  useEffect(effect, []) // onMount\n  useEffect(effect, [storageContext]) // onUpdate\n\n  return { ...state, setData }\n}\n"],"names":["useState"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAOkCA;;;;;;;;;;;;;;;;;;;qCCAG;;;;;;;;;;;;;;;;;;;ACAuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCCgBpC;;;;;;;;;;;;;;ACZkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAgHvD;;;;;;;;;mBASA;;;;;;;;;;;;;;;;;AC7H6E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BAyDzE;;;;;;;;;;;ACxD8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAwD9C;;;;;;mBAMJ;;;;;;;;iBAQF;;;;;;;;;;;;;;;;;;ACtE+D;;AAEsC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAgCnF;;;;;;;;;;;;;;;;;;;;;;ACnCiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uCCA7B;;;;;;;;;;;;;;;;;;;;ACC8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAyD9C;;;;;;mBAMJ;;;;;;;;iBAQF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}